# Checkpoint 2 Writeup

> **实现 TCPReceiver**
>
> 现在，在实验 2 中，你将实现 TCP 中处理入站字节流的部分：`TCPReceiver`。在编写 `StreamReassembler`和 `ByteStream`时，你已经完成了其中大部分的“算法”工作；本周主要讨论如何将这些类连接到 TCP 格式。这将涉及到考虑 TCP 如何表示每个字节在流中的位置——即所谓的”序列号”。`TCPReceiver`负责告诉发送方
>
> - (a) 它能够成功地组装多少入站字节流（这被称为“确认(ack)”）。
> - (b) 发送方现在被允许发送的字节范围（“流控制窗口”）。

实验内容：实现 TCP 接受方

- 正确的接受数据包
- 重新组装
- 发送到内存
- 返回确认和流量控制信号

---

任务 1：完成序列号

- 绝对序列号 ： 网络通讯中的实际上的序列号 包括开始结尾
- 序列号 ： 包含 ISN 网络传输中 包中的序列号 包括开始结尾
- 流序号 ： 在流中的位置 不包括开始结尾

流和绝对序列号很好转换 流 = 绝对+1

但是 序列号和绝对序列号并不是很好转换 我们需要处理两方向的转换

绝对序列号 -> 序列号：

    这里需要ISN 也就是随机的起点 当我们绝对序列号为x 的时候 我们的序列号就是 (x + ISN) % 序列长度

序列号 -> 绝对序列号:

    这里也需要ISN 也就是随机的起点 当我们序列号为y的时候 可能对应相当多的绝对序列号 比如序列长度\*1 + （y - ISN + 序列长度) % 序列长度  或者 序列长度 \*2 + （y - ISN + 序列长度) % 序列长度 等等

    为了消除这种二义性 我们引入了检查点（checkpoint) 利用检查点 我们可以确定最接近的绝对序列号 从而消除二义性

开始时间：2023/10/9 - 11.00

完成截图：

![png2-1](./png/png2-1.png)

任务成果：

- 我们得到了一个新的类型 Wrap

  static Wrap32 wrap( uint64_t n,Wrap32 zero_point ); 用于生成一个本类型 传入参数为绝对序列号和 ISN

  uint64_t unwrap( Wrap32 zero_point,uint64_t checkpoint ) const;用于返回基于一个 ISN 和 checkpoint 对应的序列号的绝对序列号数值

结束时间： 2023/10/9 - 15.00

---
